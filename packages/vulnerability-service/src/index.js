import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import axios from 'axios';
import { prisma } from 'database-service';
import { TARGETS } from '../config.js';

dotenv.config();

const app = express();
app.use(cors());
app.use(express.json());

const PORT = process.env.VULNERABILITY_SERVICE_PORT || 5001;
const JIRA_SERVICE_URL = process.env.JIRA_SERVICE_URL || 'http://localhost:3007';
const GITHUB_SERVICE_URL = process.env.GITHUB_SERVICE_URL || 'http://localhost:3008';
const NOTIFICATION_SERVICE_URL = process.env.NOTIFICATION_SERVICE_URL || 'http://localhost:3006';

// This is a direct translation of the original TARGETS config.
const SCAN_TARGETS = TARGETS;

async function sendSlackNotification(vulnerability, repository) {
    const message = `🚨 New ${vulnerability.severity} Vulnerability Detected: *${vulnerability.description}* in repository _${repository.fullName}_. <${vulnerability.githubAlertUrl}|View Alert>`;
    try {
        await axios.post(`${NOTIFICATION_SERVICE_URL}/api/notifications/slack`, { message });
        console.log(`Notification sent for ${vulnerability.description}`);
    } catch (error) {
        console.error(`Failed to send Slack notification: ${error.message}`);
    }
}

async function upsertVulnerabilityData(alert, repoFullName) {
    const isDependabot = !!alert.security_advisory;
    const severity = isDependabot ? alert.security_vulnerability.severity : alert.rule.security_severity_level;
    if (!['critical', 'high'].includes(severity?.toLowerCase())) return;

    const uniqueKey = isDependabot ? `Dependabot::${alert.security_advisory.ghsa_id}` : `CodeScanning::${alert.rule.id}`;
    const status = alert.state === 'open' ? 'OPEN' : 'RESOLVED';
    
    const vulnData = {
        description: isDependabot ? alert.security_advisory.summary : alert.rule.description,
        severity: severity,
        package: isDependabot ? alert.security_vulnerability.package.name : alert.tool.name,
        type: isDependabot ? 'Dependabot' : 'CodeScanning',
        githubAlertUrl: alert.html_url,
    };

    const vulnerability = await prisma.vulnerability.upsert({
        where: { uniqueKey },
        update: { lastSeen: new Date() },
        create: { uniqueKey, ...vulnData },
    });

    const repository = await prisma.repository.upsert({
        where: { fullName: repoFullName },
        update: {},
        create: { fullName: repoFullName, url: `https://github.com/${repoFullName}` },
    });

    await prisma.affectedRepository.upsert({
        where: { vulnerabilityId_repositoryId: { vulnerabilityId: vulnerability.id, repositoryId: repository.id } },
        update: { status },
        create: { vulnerabilityId: vulnerability.id, repositoryId: repository.id, status },
    });

    const isBrandNew = (new Date(vulnerability.lastSeen).getTime() - new Date(vulnerability.firstSeen).getTime()) < 2000;
    if (isBrandNew && status === 'OPEN') {
        await sendSlackNotification(vulnerability, repository);
    }
}

async function runScan() {
    console.log("🚀 Starting vulnerability scan...");
    for (const target of SCAN_TARGETS) {
        const token = process.env[target.github_token_env];
        if (!token) {
            console.warn(`⚠️ Token ${target.github_token_env} not set. Skipping target.`);
            continue;
        }

        let repoNamesToScan = [];
        if (target.team_slug) {
            const teamReposResponse = await axios.post(`${GITHUB_SERVICE_URL}/api/team-repos`, { token, org: target.org, team_slug: target.team_slug });
            repoNamesToScan = teamReposResponse.data;
        } else if (target.repos) {
            repoNamesToScan = target.repos;
        }

        for (const repoFullName of repoNamesToScan) {
            try {
                const [owner, repo] = repoFullName.split('/');
                const alertsResponse = await axios.post(`${GITHUB_SERVICE_URL}/api/repo-alerts`, { token, owner, repo });
                for (const alert of alertsResponse.data) {
                    await upsertVulnerabilityData(alert, repoFullName);
                }
            } catch (error) {
                 console.error(`Failed to process repo ${repoFullName}: ${error.message}`);
            }
        }
    }
    console.log("✅ Scan complete.");
}

// --- API Endpoints ---
app.post('/api/scan', (req, res) => {
    runScan().catch(error => console.error("Fatal error during background scan:", error));
    res.status(202).json({ message: "Scan initiated." });
});

app.get('/api/vulnerabilities', async (req, res) => {
    try {
        const data = await prisma.affectedRepository.findMany({
            where: req.query, // Pass filters directly
            include: { vulnerability: true, repository: true, jiraTicket: true },
            orderBy: { vulnerability: { severity: 'desc' } },
        });
        res.json(data);
    } catch (error) {
        res.status(500).json({ message: "Database query failed." });
    }
});

app.post('/api/vulnerability/:vulnId/create-ticket', async (req, res) => {
    try {
        const { vulnId } = req.params;
        const { affectedRepoIds } = req.body;
        const vulnerability = await prisma.vulnerability.findUnique({ where: { id: vulnId } });
        if (!vulnerability) return res.status(404).send();

        const issueData = { fields: { project: { key: process.env.JIRA_PROJECT_KEY }, summary: `[Vulnerability] ${vulnerability.description}`, issuetype: { name: "Task" } } };
        const jiraResponse = await axios.post(`${JIRA_SERVICE_URL}/api/issue`, issueData);
        
        const newTicket = await prisma.remediationTicket.create({
            data: { ticketKey: jiraResponse.data.key, url: `https://${process.env.JIRA_HOST}/browse/${jiraResponse.data.key}`, status: 'To Do' },
        });

        await prisma.affectedRepository.updateMany({ where: { id: { in: affectedRepoIds } }, data: { jiraTicketId: newTicket.id } });
        res.status(201).json(newTicket);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
});

app.post('/api/affected-repository/:id/link-ticket', async (req, res) => {
    const { id } = req.params;
    const { jiraKey } = req.body;
    try {
        const jiraResponse = await axios.post(`${JIRA_SERVICE_URL}/api/jql`, { jql: `issuekey = "${jiraKey}"` });
        if (!jiraResponse.data || jiraResponse.data.length === 0) return res.status(404).json({ message: "Jira issue not found." });
        const jiraIssue = jiraResponse.data[0];

        const ticket = await prisma.remediationTicket.upsert({
            where: { ticketKey: jiraKey },
            update: { status: jiraIssue.fields.status.name },
            create: { ticketKey: jiraKey, url: `https://${process.env.JIRA_HOST}/browse/${jiraKey}`, status: jiraIssue.fields.status.name },
        });

        await prisma.affectedRepository.update({ where: { id }, data: { jiraTicketId: ticket.id } });
        res.status(200).json(ticket);
    } catch (error) {
        res.status(500).json({ message: error.message });
    }
});

app.delete('/api/affected-repository/:id/link-ticket', async (req, res) => {
    const { id } = req.params;
    try {
        await prisma.affectedRepository.update({ where: { id }, data: { jiraTicketId: null } });
        res.status(204).send();
    } catch (error) {
        res.status(500).json({ message: 'Failed to unlink ticket.' });
    }
});

app.post('/api/tickets/sync', async (req, res) => {
    res.status(202).json({ message: "Jira ticket sync initiated." });
    // Run sync in background
    (async () => {
        const ticketsInDb = await prisma.remediationTicket.findMany();
        for (const ticket of ticketsInDb) {
            try {
                const jiraResponse = await axios.post(`${JIRA_SERVICE_URL}/api/jql`, { jql: `issuekey = "${ticket.ticketKey}"`, fields: ['status'] });
                if (jiraResponse.data && jiraResponse.data.length > 0) {
                    const newStatus = jiraResponse.data[0].fields.status.name;
                    if (ticket.status !== newStatus) {
                        await prisma.remediationTicket.update({ where: { id: ticket.id }, data: { status: newStatus } });
                    }
                }
            } catch (error) {
                console.error(`Failed to sync ticket ${ticket.ticketKey}: ${error.message}`);
            }
        }
    })();
});

app.listen(PORT, () => {
    console.log(`🚀 Vulnerability Service running on http://localhost:${PORT}`);
});