import React, { useState, useEffect, useMemo } from 'react';
import axios from 'axios';
import { Container, Typography, Box, Alert, CircularProgress, Pagination } from '@mui/material';
import Dashboard from './components/Dashboard';
import Header from './components/Header';
import FilterControls from './components/FilterControls';
import SummaryStats from './components/SummaryStats';

function App() {
    const [vulnerabilities, setVulnerabilities] = useState([]); // Raw, filtered data from API
    const [isLoading, setIsLoading] = useState(true);
    const [isScanning, setIsScanning] = useState(false);
    const [error, setError] = useState(null);
    const [filters, setFilters] = useState({ repository: '', status: 'OPEN' });
    const [groupBy, setGroupBy] = useState('vulnerability');
    const [page, setPage] = useState(1);
    const pageSize = 25;

    const fetchVulnerabilities = async () => {
        setIsLoading(true);
        setError(null);
        try {
            const response = await axios.get('/api/vulnerabilities', {
                params: { ...filters }
            });
            setVulnerabilities(response.data);
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to fetch data from the server.');
            setVulnerabilities([]);
        } finally {
            setIsLoading(false);
        }
    };

    // Re-fetch data only when filters change
    useEffect(() => {
        fetchVulnerabilities();
    }, [filters]);

    const handleScan = async () => {
        setIsScanning(true);
        setError(null);
        try {
            await axios.post('/api/scan');
            setTimeout(() => {
                fetchVulnerabilities();
            }, 3000);
        } catch (err) {
            setError(err.response?.data?.message || 'Failed to initiate scan.');
        } finally {
            setIsScanning(false);
        }
    };

    // Calculate stats from the full filtered list of vulnerabilities
    const stats = useMemo(() => {
        const counters = {
            openCritical: 0,
            openHigh: 0,
            totalResolved: 0,
            reposWithOpenIssues: new Set(),
        };

        vulnerabilities.forEach(item => {
            const severity = item.vulnerability.severity.toLowerCase();
            if (item.status === 'OPEN') {
                if (severity === 'critical') counters.openCritical++;
                if (severity === 'high') counters.openHigh++;
                counters.reposWithOpenIssues.add(item.repository.fullName);
            } else if (item.status === 'RESOLVED') {
                if (severity === 'critical' || severity === 'high') {
                    counters.totalResolved++;
                }
            }
        });

        return {
            ...counters,
            reposWithOpenIssues: counters.reposWithOpenIssues.size,
        };
    }, [vulnerabilities]);
    
    // Group the ENTIRE filtered dataset
    const groupedData = useMemo(() => {
        const grouped = vulnerabilities.reduce((acc, current) => {
            const key = groupBy === 'vulnerability' ? current.vulnerability.id 
                      : groupBy === 'repository' ? current.repository.id 
                      : current.status;

            const groupTitle = groupBy === 'vulnerability' ? current.vulnerability 
                             : groupBy === 'repository' ? current.repository 
                             : { id: current.status, name: current.status };

            if (!acc[key]) {
                acc[key] = {
                    groupInfo: groupTitle,
                    instances: [],
                };
            }
            acc[key].instances.push(current);
            return acc;
        }, {});

        return Object.values(grouped);
    }, [vulnerabilities, groupBy]);

    // Paginate the GROUPED data on the frontend
    const paginatedGroups = useMemo(() => {
        const start = (page - 1) * pageSize;
        const end = start + pageSize;
        return groupedData.slice(start, end);
    }, [groupedData, page, pageSize]);

    const handlePageChange = (event, value) => {
        setPage(value);
    };

    const handleFilterChange = (newFilters) => {
        setPage(1); // Reset to page 1 when filters change
        setFilters(newFilters);
    };

    return (
        <>
            <Header onScan={handleScan} isLoading={isScanning} />
            <Container maxWidth="xl" sx={{ mt: 4, mb: 4 }}>
                {!isLoading && <SummaryStats stats={stats} />}
                
                <FilterControls 
                    filters={filters} 
                    setFilters={handleFilterChange}
                    groupBy={groupBy}
                    setGroupBy={setGroupBy}
                />
                
                {error && ( <Alert severity="error" sx={{ mb: 2 }}><strong>Error:</strong> {error}</Alert> )}

                {isLoading ? ( 
                    <Box textAlign="center" sx={{ mt: 8 }}>
                        <CircularProgress />
                        <Typography>Loading vulnerabilities...</Typography>
                    </Box> 
                ) : (
                    <>
                        <Dashboard 
                            groupedData={paginatedGroups}
                            groupBy={groupBy}
                            onDataRefresh={fetchVulnerabilities} 
                        />
                        <Box sx={{ display: 'flex', justifyContent: 'center', mt: 4 }}>
                            <Pagination 
                                count={Math.ceil(groupedData.length / pageSize)} 
                                page={page} 
                                onChange={handlePageChange}
                                color="primary"
                            />
                        </Box>
                    </>
                )}
            </Container>
        </>
    );
}

export default App;